---
title: "Thesis Data Work"
author: Aaron DiLorenzo
date: "Jan 19, 2024"
format: 
  html:
    theme: cosmo
    toc: true
    toc-depth: 4
    toc-expand: 2
    code-fold: show
    code-summary: "Show code"
    code-link: true
    code-overflow: scroll
    code-line-numbers: true
    code-copy: true
    include-in-header:
      text: |
        <style>
        /* Replace "Published" with "Last updated" */
        .quarto-title-block .date::before {
          content: "Last updated: ";
          display: inline;
        }
        .quarto-title-block .date em {
          display: none;
        }
        </style>
    
execute:
  enabled: true
  python: false

  echo: true      
  eval: true     
  warning: false
  message: true
  cache: true
  freeze: auto
  
number-sections: true
self-contained: true  
---

### Merged and Transformed PQI Data

This python script transforms individual raw data sets from the OECD’s Quality Indicator, Cohort, and HAN/HARM databases into analysis-ready patent quality indicators, following the OECD paper’s methodology. Patent statistics vary greatly across time and region, so the script applies normalization/winsorization procedures, and produces both patent-level and country-year aggregated datasets suitable for econometric analysis of innovation quality. Source: Squicciarini, M., Dernis, H., & Criscuolo, C. (2013). Measuring Patent Quality: Indicators of Technological and Economic Value. OECD Science, Technology and Industry Working Papers, 2013/03.

```python

"""
OECD Patent Quality Indicators - Data handling: merging, normalization, and aggregation of patent quality data
"""


import polars as pl
import os



OUTPUT_DIR = "/Users/aarondilorenzo/Desktop/DATATHES/FINAL WORKING DATA"
os.makedirs(OUTPUT_DIR, exist_ok=True)


# input files
INDICATORS_FILE = "/Users/aarondilorenzo/Desktop/DATATHES/202502_OECD_PATENT_QUALITY_EPO_INDIC.txt"
COHORTS_FILE = "/Users/aarondilorenzo/Desktop/DATATHES/202502_OECD_PATENT_QUALITY_EPO_INDIC_COHORT.txt"
HAN_PATENTS_FILE = "/Users/aarondilorenzo/Desktop/DATATHES/202502_HAN_PATENTS.txt"
HARM_NAMES_FILE = "/Users/aarondilorenzo/Desktop/DATATHES/202502_HARM_NAMES.txt"


# output files
FINAL_PATENT_FILE = "OECD_patent_quality_final.parquet"
FINAL_COUNTRY_FILE = "OECD_country_year_final.csv"


# indicator categories
WINSOR_VARS = ["family_size", "grant_lag", "bwd_cits", "npl_cits", "claims", "fwd_cits5", "fwd_cits7"]
COMPOSITE_VARS = ["generality", "originality", "radicalness", "quality_index_4", "quality_index_6"]
BINARY_VARS = ["breakthrough"]


def load_data():
    """Load and prepare all source datasets"""
    
    # Load cohort statistics for normalization
    cohorts = pl.read_csv(
        COHORTS_FILE,
        separator="|",
        null_values=["", "NA"],
        dtypes={col: pl.Utf8 for col in [
            "filing", "tech_field", "variable", "patents", "mean", "std_dev", 
            "kurtosis", "skewness", "p1", "p10", "p25", "p50", "p75", "p90", "p99", "max"
        ]},
        infer_schema_length=0
    )
    
    # Clean column names and convert numeric types
    cohorts = cohorts.rename({col: col.strip() for col in cohorts.columns})
    numeric_cols = ["p1", "p10", "p25", "p50", "p75", "p90", "p99", "max"]
    for col in numeric_cols:
        if col in cohorts.columns:
            cohorts = cohorts.with_columns(pl.col(col).cast(pl.Float64))
    
    cohorts = cohorts.select(["filing", "tech_field", "variable", "p1", "p99", "max"])
    
    # Load main indicator data
    indicators = pl.read_csv(
        INDICATORS_FILE, 
        separator="|", 
        null_values=["", "NA"],
        infer_schema_length=10000
    )
    indicators = indicators.rename({col: col.strip() for col in indicators.columns})
    
    # Load and prepare HAN/HARM mapping data
    han = pl.read_csv(HAN_PATENTS_FILE, separator="|")
    han = han.rename({col: col.strip() for col in han.columns})
    han = han.rename({"Appln_id": "appln_id"})
    
    harm = pl.read_csv(HARM_NAMES_FILE, separator="|")
    harm = harm.rename({col: col.strip() for col in harm.columns})
    harm = harm.select(["HARM_ID", "Clean_name", "Person_ctry_code"])
    
    han = han.join(harm, on="HARM_ID", how="left").select(["appln_id", "HARM_ID", "Clean_name", "Person_ctry_code"])
    
    return cohorts, indicators, han


def apply_cohort_normalization(merged, cohorts, indicator_name, winsorize=True):
    """Apply cohort-specific normalization and winsorization"""
    
    col_stats = cohorts.filter(pl.col("variable") == indicator_name)
    
    if col_stats.is_empty():
        return merged
    
    merged = merged.join(
        col_stats.select(["filing", "tech_field", "p1", "p99", "max"]),
        on=["filing", "tech_field"],
        how="left"
    )
    
    # Special handling for grant_lag transformation
    if indicator_name == "grant_lag":
        merged = merged.with_columns(
            (1 - (pl.col("grant_lag") / pl.col("max"))).alias("grant_lag_transformed")
        )
        
        if winsorize:
            merged = merged.with_columns(
                pl.when(pl.col("grant_lag_transformed") < (1 - pl.col("p99")/pl.col("max"))).then(1 - pl.col("p99")/pl.col("max"))
                .when(pl.col("grant_lag_transformed") > (1 - pl.col("p1")/pl.col("max"))).then(1 - pl.col("p1")/pl.col("max"))
                .otherwise(pl.col("grant_lag_transformed"))
                .alias("grant_lag_transformed_winsorized")
            )
            merged = merged.with_columns(
                pl.col("grant_lag_transformed_winsorized").alias("grant_lag_norm")
            ).drop(["grant_lag_transformed_winsorized", "p1", "p99", "max", "grant_lag_transformed"])
        else:
            merged = merged.with_columns(
                pl.col("grant_lag_transformed").alias("grant_lag_norm")
            ).drop(["p1", "p99", "max", "grant_lag_transformed"])
    
    else:
        # Standard normalization for other indicators
        if winsorize and indicator_name in WINSOR_VARS:
            merged = merged.with_columns(
                pl.when(pl.col(indicator_name) < pl.col("p1")).then(pl.col("p1"))
                .when(pl.col(indicator_name) > pl.col("p99")).then(pl.col("p99"))
                .otherwise(pl.col(indicator_name))
                .alias(f"{indicator_name}_winsorized")
            )
            merged = merged.with_columns(
                (pl.col(f"{indicator_name}_winsorized") / pl.col("max")).alias(f"{indicator_name}_norm")
            ).drop([f"{indicator_name}_winsorized", "p1", "p99", "max"])
        else:
            merged = merged.with_columns(
                (pl.col(indicator_name) / pl.col("max")).alias(f"{indicator_name}_norm")
            ).drop(["p1", "p99", "max"])
    
    return merged


def main():
    """Main data processing pipeline"""
    
    # Load data
    cohorts, indicators, han = load_data()
    
    # Ensure consistent data types
    indicators = indicators.with_columns([
        pl.col("filing").cast(pl.Utf8),
        pl.col("tech_field").cast(pl.Utf8)
    ])
    
    cohorts = cohorts.with_columns([
        pl.col("filing").cast(pl.Utf8),
        pl.col("tech_field").cast(pl.Utf8)
    ])
    
    # Merge with HAN/HARM data
    merged = indicators.join(han, on="appln_id", how="left")
    
    # Apply normalization by indicator type
    standard_indicators = ["patent_scope", "family_size", "grant_lag", "bwd_cits", "npl_cits", "claims", "fwd_cits5", "fwd_cits7"]
    
    for indicator in standard_indicators:
        if indicator in merged.columns:
            merged = apply_cohort_normalization(merged, cohorts, indicator, winsorize=True)
    
    # Handle composite indicators (use as-is)
    # Handle breakthrough (binary indicator)
    if "breakthrough" in merged.columns:
        merged = merged.with_columns([
            pl.col("breakthrough").fill_null(0).cast(pl.Int8).alias("breakthrough")
        ])
    
    # Handle renewal (raw counts)
    if "renewal" in merged.columns:
        merged = merged.with_columns([
            pl.col("renewal").cast(pl.Float64).alias("renewal")
        ])
    
    # Aggregate to country-year level
    norm_columns = [col for col in merged.columns if col.endswith('_norm')]
    
    agg_exprs = []
    
    # Normalized indicators: take mean
    for col in norm_columns:
        agg_exprs.append(pl.mean(col).alias(f"avg_{col}"))
    
    # Composite indicators: take mean of raw values
    for col in COMPOSITE_VARS:
        if col in merged.columns:
            agg_exprs.append(pl.mean(col).alias(f"avg_{col}"))
    
    # Breakthrough: calculate percentage
    if "breakthrough" in merged.columns:
        agg_exprs.append(
            (pl.sum("breakthrough") / pl.count("breakthrough")).alias("pct_breakthrough")
        )
    
    # Renewal: average renewal count
    if "renewal" in merged.columns:
        agg_exprs.append(pl.mean("renewal").alias("avg_renewal"))
    
    # Perform aggregation
    country_agg = (
        merged
        .filter(pl.col("Person_ctry_code").is_not_null())
        .group_by(["Person_ctry_code", "filing"])
        .agg(agg_exprs)
        .rename({"Person_ctry_code": "country_code", "filing": "year"})
        .sort(["country_code", "year"])
    )
    
    # Save final datasets
    patent_path = os.path.join(OUTPUT_DIR, FINAL_PATENT_FILE)
    merged.write_parquet(patent_path)
    
    country_path = os.path.join(OUTPUT_DIR, FINAL_COUNTRY_FILE)
    country_agg.write_csv(country_path)


if __name__ == "__main__":
    main()



```

### Combining the Patent Quality Indicators with Additional Variables (Park Index, Financial Development Measures, & Controls)
```{r echo= TRUE, eval= TRUE}

library(tidyverse)
library(data.table)

options(dplyr.summarise.inform = FALSE)

data_dir <- "data"
out_file <- file.path(data_dir, "monarch_panel_raw.csv")

# load the datasets
quality  <- fread(file.path(data_dir, "quality_final.csv"))
vc       <- fread(file.path(data_dir, "VC_final.csv"))
park     <- fread(file.path(data_dir, "Park_final.csv"))
controls <- fread(file.path(data_dir, "Controls_final.csv"))
finance  <- fread(file.path(data_dir, "FD_Final.csv"))
counts   <- fread(file.path(data_dir, "counts_res_final.csv"))



stopifnot(!anyDuplicated(quality[, .(iso3c, year)]))

monarch <- quality

#drop dupe columns

vc <- vc %>%
  select(iso3c, year, VC_investment)

stopifnot(!anyDuplicated(vc[, .(iso3c, year)]))

monarch <- monarch %>%
  left_join(vc, by = c("iso3c", "year"))

#drop dupe columns

park <- park %>%
  filter(!is.na(iso3c), iso3c != "") %>%
  select(iso3c, year, ipp_index_IP_transformed)

stopifnot(!anyDuplicated(park[, .(iso3c, year)]))

monarch <- monarch %>%
  left_join(park, by = c("iso3c", "year"))

#clean the controls

controls <- controls %>%
  select(
    iso3c, year,
    gdp_pc_const2015usd,
    trade_percent_gdp,
    rd_expenditure_percent_gdp,
    tertiary_enrollment_percent,
    researchers_per_million,
    population_total
  ) %>%
  mutate(across(
    -c(iso3c, year),
    ~ as.numeric(na_if(.x, ".."))
  ))

stopifnot(!anyDuplicated(controls[, .(iso3c, year)]))

monarch <- monarch %>%
  left_join(controls, by = c("iso3c", "year"))

#clean fd variables

finance <- finance %>%
  select(
    iso3c, year,
    bank_credit_gdp,
    market_cap_gdp
  ) %>%
  mutate(across(
    -c(iso3c, year),
    ~ as.numeric(na_if(.x, ".."))
  ))

stopifnot(!anyDuplicated(finance[, .(iso3c, year)]))

monarch <- monarch %>%
  left_join(finance, by = c("iso3c", "year"))

#ensure counts are good

counts <- counts %>%
  select(
    iso3c, year,
    patent_applications_residents
  ) %>%
  mutate(across(
    -c(iso3c, year),
    ~ as.numeric(na_if(.x, ".."))
  ))

stopifnot(!anyDuplicated(counts[, .(iso3c, year)]))

monarch <- monarch %>%
  left_join(counts, by = c("iso3c", "year"))

#double make sure no duplicates

# One row per country-year
stopifnot(!anyDuplicated(monarch[, .(iso3c, year)]))

# No missing keys (iso3c and years)
stopifnot(!any(is.na(monarch$iso3c)))
stopifnot(!any(is.na(monarch$year)))

#save the clean data

fwrite(monarch, out_file)
```
```{r eval= TRUE, echo= FALSE}
cat("rows:", nrow(monarch), "\n")
cat("countries:", n_distinct(monarch$iso3c), "\n")
cat("years:", length(unique(monarch$year)), "\n")

```
#### apply transformations
```{r eval= TRUE, echo= TRUE}

rm(list = ls())

library(tidyverse)
library(data.table)

options(dplyr.summarise.inform = FALSE)



monarch <- fread("data/monarch_panel_raw.csv")



monarch_t <- monarch %>%
  
  # normalise counts based on researchers
  mutate(
    researchers_total = researchers_per_million * (population_total / 1e6),
    patents_per_1000_researchers =
      (patent_applications_residents / researchers_total) * 1000,
    patents_per_1000_researchers =
      ifelse(
        is.infinite(patents_per_1000_researchers) |
          patents_per_1000_researchers < 0,
        NA,
        patents_per_1000_researchers
      )
  ) %>%
  
  #scale quality for interpretability
  mutate(
    quality_index_100 = avg_quality_index_4 * 100
  ) %>%
  
  #log variables
  
  mutate(
    ln_patents = log(patents_per_1000_researchers + 1),
    ln_gdp_pc  = log(gdp_pc_const2015usd + 1),
    ln_bank    = log(bank_credit_gdp + 1),
    ln_market = log(market_cap_gdp + 1),
    ln_vc     = log(VC_investment + 1),
    ln_trade  = log(trade_percent_gdp + 1),
    ln_rd     = log(rd_expenditure_percent_gdp + 1),
    ln_tertiary = log(tertiary_enrollment_percent + 1)
  ) %>%
  
  #mean center the park index
  
  mutate(
    ipr_c = ipp_index_IP_transformed -
      mean(ipp_index_IP_transformed, na.rm = TRUE)
  ) %>%
  
  #interactions
  
  mutate(
    ln_bank_x_ipr   = ln_bank   * ipr_c,
    ln_market_x_ipr = ln_market * ipr_c,
    ln_vc_x_ipr     = ln_vc     * ipr_c
  )

#save
fwrite(monarch_t, "data/monarch_panel_transformed.csv")
```

```{r eval= TRUE, echo= FALSE}
cat("rows:", nrow(monarch_t), "\n")
cat("countries:", n_distinct(monarch_t$iso3c), "\n")

```

### Executing the Analysis 
```{r eval= TRUE, echo= TRUE}

rm(list = ls())

library(tidyverse)
library(data.table)
library(plm)
library(stargazer)
library(lmtest)
library(sandwich)

options(dplyr.summarise.inform = FALSE)

#load data

df <- fread("data/monarch_panel_transformed.csv")

#filter nas

base_df <- df %>%
  filter(
    !is.na(quality_index_100),
    !is.na(ln_patents),
    !is.na(ipr_c),
    !is.na(ln_gdp_pc)
  )

#split the samples so vc coverage doesnt obliterate everything

bank_market <- pdata.frame(
  base_df %>% filter(!is.na(ln_bank) | !is.na(ln_market)),
  index = c("iso3c", "year")
)

vc_sample <- pdata.frame(
  base_df %>% filter(!is.na(ln_vc)),
  index = c("iso3c", "year")
)

#quality models

qual_bank <- plm(
  quality_index_100 ~ ln_bank + ipr_c + ln_bank_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = bank_market,
  model = "within",
  effect = "twoways"
)

qual_market <- plm(
  quality_index_100 ~ ln_market + ipr_c + ln_market_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = bank_market,
  model = "within",
  effect = "twoways"
)

qual_vc <- plm(
  quality_index_100 ~ ln_vc + ipr_c + ln_vc_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = vc_sample,
  model = "within",
  effect = "twoways"
)

#patent quantity models

count_bank <- plm(
  ln_patents ~ ln_bank + ipr_c + ln_bank_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = bank_market,
  model = "within",
  effect = "twoways"
)

count_market <- plm(
  ln_patents ~ ln_market + ipr_c + ln_market_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = bank_market,
  model = "within",
  effect = "twoways"
)

count_vc <- plm(
  ln_patents ~ ln_vc + ipr_c + ln_vc_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = vc_sample,
  model = "within",
  effect = "twoways"
)

#function that makes the clustered se
se <- function(model) {
  sqrt(diag(vcovHC(model, type = "HC1", cluster = "group")))
}

#patent quality table-

stargazer(
  qual_bank, qual_market, qual_vc,
  type = "text",
  title = "Financial Development, IP Protection, and Patent Quality",
  dep.var.caption = "Dependent Variable: Patent Quality (0–100)",
  column.labels = c("Bank-Based", "Market-Based", "VC-Based"),
  se = list(se(qual_bank), se(qual_market), se(qual_vc)),
  omit.stat = c("ser", "f"),
  notes = c(
    "All models include country and year fixed effects.",
    "Standard errors clustered by country.",
    "* p<0.1, ** p<0.05, *** p<0.01"
  )
)

#quantity table

stargazer(
  count_bank, count_market, count_vc,
  type = "text",
  title = "Financial Development, IP Protection, and Patent Quantity",
  dep.var.caption = "Dependent Variable: ln(Patents per 1,000 Researchers)",
  column.labels = c("Bank-Based", "Market-Based", "VC-Based"),
  se = list(se(count_bank), se(count_market), se(count_vc)),
  omit.stat = c("ser", "f"),
  notes = c(
    "All models include country and year fixed effects.",
    "Standard errors clustered by country.",
    "* p<0.1, ** p<0.05, *** p<0.01"
  )
)

```

#### closer look at the samples
```{r echo= TRUE, eval= TRUE}

rm(list = ls())

library(tidyverse)
library(data.table)
library(plm)

df <- fread("data/monarch_panel_transformed.csv")

#base sample, same as regressions
base_df <- df %>%
  filter(
    !is.na(quality_index_100),
    !is.na(ln_patents),
    !is.na(ipr_c),
    !is.na(ln_gdp_pc)
  )

#bank/market sample

bank_market_df <- base_df %>%
  filter(!is.na(ln_bank) | !is.na(ln_market))
```

```{r eval= TRUE, echo= FALSE}
cat("BANK / MARKET SAMPLE COVERAGE\n")

cat("observations:\n")
cat(nrow(bank_market_df), "\n\n")

cat("countries:\n")
cat(length(unique(bank_market_df$iso3c)), "\n\n")

cat("years covered:\n")
print(range(bank_market_df$year, na.rm = TRUE))

cat("\ncountries included:\n")
print(sort(unique(bank_market_df$iso3c)))

cat("\nyear counts (obs per year):\n")
print(table(bank_market_df$year))
```

```{r eval= TRUE, echo= FALSE}
#vc sample

vc_df <- base_df %>%
  filter(!is.na(ln_vc))


cat("VC SAMPLE COVERAGE\n")

cat("observations:\n")
cat(nrow(vc_df), "\n\n")

cat("countries:\n")
cat(length(unique(vc_df$iso3c)), "\n\n")

cat("years covered:\n")
print(range(vc_df$year, na.rm = TRUE))

cat("\ncountries included:\n")
print(sort(unique(vc_df$iso3c)))

cat("\nyear counts (obs per year):\n")
print(table(vc_df$year))

```
### ignore everything below this
```{r echo= FALSE, eval= FALSE}
rm(list = ls())
library(reticulate)
library(tidyverse)
library(plm)
library(stargazer)
library(data.table)
library(lmtest)
library(sandwich)

master <- fread("data/Master_Panel.csv")

master_clean <- master %>%
  mutate(researchers_per_million = coalesce(researchers_per_million_y, researchers_per_million_x)) %>%
  mutate(across(c(
    year, avg_quality_index_4, avg_quality_index_6, VC_investment,
    bank_credit_gdp, market_cap_gdp, ipp_index_IP_transformed,
    patent_applications_residents, researchers_per_million,
    gdp_pc_const2015usd, trade_percent_gdp,
    rd_expenditure_percent_gdp, tertiary_enrollment_percent
  ), as.numeric)) %>%
  mutate(VC_investment_pct = VC_investment * 100) %>%
  mutate(quality_index_100 = avg_quality_index_4 * 100) %>%
  mutate(patents_per_researcher = patent_applications_residents / researchers_per_million) %>%
  
  mutate(
    bank_x_ipr = bank_credit_gdp * ipp_index_IP_transformed,
    market_x_ipr = market_cap_gdp * ipp_index_IP_transformed,
    vc_x_ipr = VC_investment_pct * ipp_index_IP_transformed
  )

master_clean <- pdata.frame(master_clean, index = c("iso3c", "year"))

master_levels <- master_clean %>%
  filter(!is.na(quality_index_100) | !is.na(patents_per_researcher)) %>%
  filter(!is.na(bank_credit_gdp) | !is.na(market_cap_gdp) | !is.na(VC_investment_pct)) %>%
  filter(!is.na(ipp_index_IP_transformed))

year_range <- range(as.numeric(as.character(master_levels$year)), na.rm = TRUE)

master_bank_market <- master_levels %>% 
  filter(!is.na(bank_credit_gdp) | !is.na(market_cap_gdp))

master_vc <- master_levels %>% 
  filter(!is.na(VC_investment_pct))

# PATENT QUALITY REGRESSIONS

# Bank-based FD with IPR interaction
qual_bank <- plm(quality_index_100 ~ bank_credit_gdp + ipp_index_IP_transformed + bank_x_ipr +
                   gdp_pc_const2015usd + trade_percent_gdp +
                   rd_expenditure_percent_gdp + tertiary_enrollment_percent,
                 data = master_bank_market, model = "within", effect = "twoways")

# Market-based FD with IPR interaction  
qual_market <- plm(quality_index_100 ~ market_cap_gdp + ipp_index_IP_transformed + market_x_ipr +
                     gdp_pc_const2015usd + trade_percent_gdp +
                     rd_expenditure_percent_gdp + tertiary_enrollment_percent,
                   data = master_bank_market, model = "within", effect = "twoways")

# VC-based FD with IPR interaction
qual_vc <- plm(quality_index_100 ~ VC_investment_pct + ipp_index_IP_transformed + vc_x_ipr +
                 gdp_pc_const2015usd + trade_percent_gdp +
                 rd_expenditure_percent_gdp + tertiary_enrollment_percent,
               data = master_vc, model = "within", effect = "twoways")

# patent count regressions

# Bank FD with IPR interaction
count_bank <- plm(patents_per_researcher ~ bank_credit_gdp + ipp_index_IP_transformed + bank_x_ipr +
                    gdp_pc_const2015usd + trade_percent_gdp +
                    rd_expenditure_percent_gdp + tertiary_enrollment_percent,
                  data = master_bank_market, model = "within", effect = "twoways")

# market FD with IPR interaction
count_market <- plm(patents_per_researcher ~ market_cap_gdp + ipp_index_IP_transformed + market_x_ipr +
                      gdp_pc_const2015usd + trade_percent_gdp +
                      rd_expenditure_percent_gdp + tertiary_enrollment_percent,
                    data = master_bank_market, model = "within", effect = "twoways")

# VC FD with IPR interaction
count_vc <- plm(patents_per_researcher ~ VC_investment_pct + ipp_index_IP_transformed + vc_x_ipr +
                  gdp_pc_const2015usd + trade_percent_gdp +
                  rd_expenditure_percent_gdp + tertiary_enrollment_percent,
                data = master_vc, model = "within", effect = "twoways")

# clustering se
qual_bank_se <- sqrt(diag(vcovHC(qual_bank, type = "HC1", cluster = "group")))
qual_market_se <- sqrt(diag(vcovHC(qual_market, type = "HC1", cluster = "group")))
qual_vc_se <- sqrt(diag(vcovHC(qual_vc, type = "HC1", cluster = "group")))

count_bank_se <- sqrt(diag(vcovHC(count_bank, type = "HC1", cluster = "group")))
count_market_se <- sqrt(diag(vcovHC(count_market, type = "HC1", cluster = "group")))
count_vc_se <- sqrt(diag(vcovHC(count_vc, type = "HC1", cluster = "group")))

# stargazer tables with clustered se

stargazer(qual_bank, qual_market, qual_vc,
          type = "text",
          title = "Financial Development, IP Protection and Patent Quality",
          dep.var.labels = "Patent Quality Index (0-100 scale)",
          column.labels = c("Bank-based", "Market-based", "VC-based"),
          covariate.labels = c("Bank Credit/GDP", "Market Cap/GDP", "VC Investment/GDP",
                               "IP Protection", 
                               "Bank FD × IP Protection", 
                               "Market FD × IP Protection",
                               "VC FD × IP Protection",
                               "GDP per Capita", "Trade/GDP", 
                               "R&D Expenditure", "Tertiary Enrollment"),
          omit.stat = c("ser", "f"),
          se = list(qual_bank_se, qual_market_se, qual_vc_se),
          notes = "All specifications include country and year fixed effects. Patent quality measured on 0-100 scale. Standard errors clustered by country in parentheses.",
          notes.append = FALSE,
          align = TRUE)


stargazer(count_bank, count_market, count_vc,
          type = "text",
          title = "Financial Development, IP Protection and Patent Counts per Researcher",
          dep.var.labels = "Patents per Researcher",
          column.labels = c("Bank-based", "Market-based", "VC-based"),
          covariate.labels = c("Bank Credit/GDP", "Market Cap/GDP", "VC Investment/GDP",
                               "IP Protection", 
                               "Bank FD × IP Protection", 
                               "Market FD × IP Protection",
                               "VC FD × IP Protection",
                               "GDP per Capita", "Trade/GDP", 
                               "R&D Expenditure", "Tertiary Enrollment"),
          omit.stat = c("ser", "f"),
          se = list(count_bank_se, count_market_se, count_vc_se),
          notes = "All specifications include country and year fixed effects. All financial development measures in % of GDP. Standard errors clustered by country in parentheses.",
          notes.append = FALSE,
          align = TRUE)
##
# SAMPLE SIZE REPORT
#cat("\n\n")
#cat("===============================================================================\n")
#cat("SAMPLE SIZES\n")
#cat("===============================================================================\n")
#cat("Bank/Market Models:\n")
#cat("  Quality:", nobs(qual_bank), "observations\n")
#cat("  Counts:", nobs(count_bank), "observations\n")
#cat("VC Models:\n")
#cat("  Quality:", nobs(qual_vc), "observations\n")
#cat("  Counts:", nobs(count_vc), "observations\n")
#cat("Countries (Bank/Market):", length(unique(master_bank_market$iso3c)), "\n")
#cat("Countries (VC):", length(unique(master_vc$iso3c)), "\n")
#cat("Years:", paste0(year_range, collapse = " - "), "\n")

stargazer(qual_bank, qual_market, qual_vc,
          type = "html",
          title = "Financial Development, IP Protection and Patent Quality",
          dep.var.labels = "Patent Quality Index (0-100 scale)",
          column.labels = c("Bank-based", "Market-based", "VC-based"),
          covariate.labels = c("Bank Credit/GDP", "Market Cap/GDP", "VC Investment/GDP",
                               "IP Protection", 
                               "Bank FD × IP Protection", 
                               "Market FD × IP Protection",
                               "VC FD × IP Protection",
                               "GDP per Capita", "Trade/GDP", 
                               "R&D Expenditure", "Tertiary Enrollment"),
          omit.stat = c("ser", "f"),
          se = list(qual_bank_se, qual_market_se, qual_vc_se),
          notes = "All specifications include country and year fixed effects. Patent quality measured on 0-100 scale. Standard errors clustered by country in parentheses.",
          notes.append = FALSE,
          align = TRUE,
          out = "~/Desktop/quality_table.html")

stargazer(count_bank, count_market, count_vc,
          type = "html",
          title = "Financial Development, IP Protection and Patent Counts per Researcher",
          dep.var.labels = "Patents per Researcher",
          column.labels = c("Bank-based", "Market-based", "VC-based"),
          covariate.labels = c("Bank Credit/GDP", "Market Cap/GDP", "VC Investment/GDP",
                               "IP Protection", 
                               "Bank FD × IP Protection", 
                               "Market FD × IP Protection",
                               "VC FD × IP Protection",
                               "GDP per Capita", "Trade/GDP", 
                               "R&D Expenditure", "Tertiary Enrollment"),
          omit.stat = c("ser", "f"),
          se = list(count_bank_se, count_market_se, count_vc_se),
          notes = "All specifications include country and year fixed effects. All financial development measures in % of GDP. Standard errors clustered by country in parentheses.",
          notes.append = FALSE,
          align = TRUE,
          out = "~/Desktop/count_table.html")

stargazer(qual_bank, qual_market, qual_vc,
          type = "text",
          title = "Financial Development, IP Protection and Patent Quality",
          dep.var.labels = "Patent Quality Index (0-100 scale)",
          column.labels = c("Bank-based", "Market-based", "VC-based"),
          covariate.labels = c("GDP per Capita", "Trade/GDP", "R&D Expenditure", "Tertiary Enrollment",  
                               "Bank Credit/GDP", "Market Cap/GDP", "VC Investment/GDP",  
                               "IP Protection", 
                               "Bank FD × IP Protection", "Market FD × IP Protection", "VC FD × IP Protection"),
          keep = c("bank_credit_gdp", "market_cap_gdp", "VC_investment_pct",  
                   "ipp_index_IP_transformed", "bank_x_ipr", "market_x_ipr", "vc_x_ipr",
                   "gdp_pc_const2015usd", "trade_percent_gdp", "rd_expenditure_percent_gdp", "tertiary_enrollment_percent"),
          omit.stat = c("ser", "f"),
          se = list(qual_bank_se, qual_market_se, qual_vc_se),
          notes = "All specifications include country and year fixed effects. Standard errors clustered by country.",
          notes.append = FALSE,
          align = TRUE)
```
the preliminary results are currently hidden for neatness, as i'd imagine the final R script will more closely resemble the ones below. I can make them reappear at any time

```{r echo= FALSE, eval= FALSE}
#regression tables script
library(tidyverse)
library(data.table)
library(plm)
library(lmtest)
library(sandwich)
library(stargazer)


master <- fread("data/Master_Panel.csv")
summary(master)
master_clean <- master %>%
  
  # fix the researcher duplicate
  mutate(researchers_per_million = coalesce(
    as.numeric(researchers_per_million_y),
    as.numeric(researchers_per_million_x)
  )) %>%
  
  # convert numerics 
  mutate(across(c(
    year,
    avg_quality_index_4,
    avg_quality_index_6,
    VC_investment,
    bank_credit_gdp,
    market_cap_gdp,
    ipp_index_IP_transformed,
    patent_applications_residents,
    gdp_pc_const2015usd,
    trade_percent_gdp,
    rd_expenditure_percent_gdp,
    tertiary_enrollment_percent
  ), as.numeric)) %>%
  
  # scale variables for interpretability and accuracy
  mutate(
    VC_investment_pct = VC_investment * 100,
    quality_index_100 = avg_quality_index_4 * 100,
    patents_per_1000_researchers =
      patent_applications_residents / (researchers_per_million * 1000)
  ) %>%
  
  # create interaction terms
  mutate(
    bank_x_ipr   = bank_credit_gdp   * ipp_index_IP_transformed,
    market_x_ipr = market_cap_gdp    * ipp_index_IP_transformed,
    vc_x_ipr     = VC_investment_pct * ipp_index_IP_transformed
  )

# bank and mkt sample
bm_sample <- master_clean %>%
  filter(
    !is.na(quality_index_100),
    !is.na(patents_per_1000_researchers),
    !is.na(ipp_index_IP_transformed),
    !is.na(gdp_pc_const2015usd),
    !is.na(trade_percent_gdp),
    !is.na(rd_expenditure_percent_gdp),
    !is.na(tertiary_enrollment_percent),
    !is.na(bank_credit_gdp) | !is.na(market_cap_gdp)
  )

bm_panel <- pdata.frame(bm_sample, index = c("iso3c", "year"))

#VC sample 
vc_sample <- master_clean %>%
  filter(
    !is.na(quality_index_100),
    !is.na(patents_per_1000_researchers),
    !is.na(VC_investment_pct),
    !is.na(ipp_index_IP_transformed),
    !is.na(gdp_pc_const2015usd),
    !is.na(trade_percent_gdp),
    !is.na(rd_expenditure_percent_gdp),
    !is.na(tertiary_enrollment_percent)
  )

vc_panel <- pdata.frame(vc_sample, index = c("iso3c", "year"))


#regressions: quality


qual_bank <- plm(
  quality_index_100 ~ bank_credit_gdp + ipp_index_IP_transformed + bank_x_ipr +
    gdp_pc_const2015usd + trade_percent_gdp +
    rd_expenditure_percent_gdp + tertiary_enrollment_percent,
  data = bm_panel,
  model = "within",
  effect = "twoways"
)

qual_market <- plm(
  quality_index_100 ~ market_cap_gdp + ipp_index_IP_transformed + market_x_ipr +
    gdp_pc_const2015usd + trade_percent_gdp +
    rd_expenditure_percent_gdp + tertiary_enrollment_percent,
  data = bm_panel,
  model = "within",
  effect = "twoways"
)

# VC: interaction retained but interpreted cautiously
qual_vc <- plm(
  quality_index_100 ~ VC_investment_pct + ipp_index_IP_transformed + vc_x_ipr +
    gdp_pc_const2015usd + trade_percent_gdp +
    rd_expenditure_percent_gdp + tertiary_enrollment_percent,
  data = vc_panel,
  model = "within",
  effect = "twoways"
)

# Regressions: counts

count_bank <- plm(
  patents_per_1000_researchers ~ bank_credit_gdp + ipp_index_IP_transformed + bank_x_ipr +
    gdp_pc_const2015usd + trade_percent_gdp +
    rd_expenditure_percent_gdp + tertiary_enrollment_percent,
  data = bm_panel,
  model = "within",
  effect = "twoways"
)

count_market <- plm(
  patents_per_1000_researchers ~ market_cap_gdp + ipp_index_IP_transformed + market_x_ipr +
    gdp_pc_const2015usd + trade_percent_gdp +
    rd_expenditure_percent_gdp + tertiary_enrollment_percent,
  data = bm_panel,
  model = "within",
  effect = "twoways"
)

count_vc <- plm(
  patents_per_1000_researchers ~ VC_investment_pct + ipp_index_IP_transformed + vc_x_ipr +
    gdp_pc_const2015usd + trade_percent_gdp +
    rd_expenditure_percent_gdp + tertiary_enrollment_percent,
  data = vc_panel,
  model = "within",
  effect = "twoways"
)


#clustered SE

se <- function(model) {
  sqrt(diag(vcovHC(model, type = "HC1", cluster = "group")))
}

qual_se   <- list(se(qual_bank), se(qual_market), se(qual_vc))
count_se  <- list(se(count_bank), se(count_market), se(count_vc))

#stargazer tables

stargazer(
  qual_bank, qual_market, qual_vc,
  type = "text",
  title = "Financial Development, IP Protection, and Patent Quality",
  dep.var.labels = "",
  dep.var.caption = "Dependant Variable: Patent Quality Index (0–100) ",
  column.labels = c("Bank-Based", "Market-Based", "VC-Based"),
  keep = c(
    "bank_credit_gdp", "market_cap_gdp", "VC_investment_pct",
    "ipp_index_IP_transformed",
    "bank_x_ipr", "market_x_ipr", "vc_x_ipr",
    "gdp_pc_const2015usd", "trade_percent_gdp",
    "rd_expenditure_percent_gdp", "tertiary_enrollment_percent"
  ),
  covariate.labels = c(
    "Bank Credit / GDP",
    "Market Capitalization / GDP",
    "VC Investment / GDP",
    "IP Protection",
    "Bank FD × IP Protection",
    "Market FD × IP Protection",
    "VC FD × IP Protection",
    "GDP per Capita",
    "Trade / GDP",
    "R&D Expenditure / GDP",
    "Tertiary Enrollment"
  ),
  se = qual_se,
  omit.stat = c("ser", "f"),
  notes = "All models include country and year fixed effects. Standard errors clustered by country.",
  align = TRUE
)

stargazer(
  count_bank, count_market, count_vc,
  type = "text",
  title = "Financial Development, IP Protection, and Patent Quantity",
  dep.var.labels = "",
  dep.var.caption = "Dependant Variable: Patents per 1,000 Researchers",
  column.labels = c("Bank-Based", "Market-Based", "VC-Based"),
  keep = c(
    "bank_credit_gdp", "market_cap_gdp", "VC_investment_pct",
    "ipp_index_IP_transformed",
    "bank_x_ipr", "market_x_ipr", "vc_x_ipr",
    "gdp_pc_const2015usd", "trade_percent_gdp",
    "rd_expenditure_percent_gdp", "tertiary_enrollment_percent"
  ),
  covariate.labels = c(
    "Bank Credit / GDP",
    "Market Capitalization / GDP",
    "VC Investment / GDP",
    "IP Protection",
    "Bank FD × IP Protection",
    "Market FD × IP Protection",
    "VC FD × IP Protection",
    "GDP per Capita",
    "Trade / GDP",
    "R&D Expenditure / GDP",
    "Tertiary Enrollment"
  ),
  se = count_se,
  omit.stat = c("ser", "f"),
  notes = "All models include country and year fixed effects. Standard errors clustered by country.",
  align = TRUE
)
```
#### Squeezing the data (now log transformations have been applied)

This R script runs panel data regressions to investigate how bank-based, market-based, and venture capital financial development interact with intellectual property protection to influence patent quality and quantity. The methodology uses two-way fixed effects models with country and year controls, clustering standard errors by country. All continuous variables are log-transformed, interaction terms capture how IP protection moderates financial development effects. Three separate models test each financial system type, controlling for GDP per capita, trade openness, R&D expenditure, and tertiary education 

#### log transformations

```{r echo= FALSE, eval= FALSE}
# squeezing the data, applying log transformations

rm(list = ls())
library(tidyverse)
library(data.table)
library(plm)
library(stargazer)
library(lmtest)
library(sandwich)

# Load data
master <- fread("data/Master_Panel.csv")

# Clean and transform data 
master_clean <- master %>%
  # fix the researcher variable
  mutate(
    researchers_per_million = coalesce(
      as.numeric(researchers_per_million_y),
      as.numeric(researchers_per_million_x)
    ),
    population_total = as.numeric(population_total)
  ) %>%
  
  # Convert variables to numeric
  mutate(across(c(
    year, avg_quality_index_4, VC_investment,
    bank_credit_gdp, market_cap_gdp, ipp_index_IP_transformed,
    patent_applications_residents, gdp_pc_const2015usd,
    trade_percent_gdp, rd_expenditure_percent_gdp,
    tertiary_enrollment_percent
  ), as.numeric)) %>%
  
  # proper scaling
  mutate(
    researchers_total = researchers_per_million * (population_total / 1000000),
    patents_per_1000_researchers = (patent_applications_residents / researchers_total) * 1000,
    patents_per_1000_researchers = ifelse(
      is.infinite(patents_per_1000_researchers) | 
        patents_per_1000_researchers < 0,
      NA, 
      patents_per_1000_researchers
    )
  ) %>%
  
  # scale variables
  mutate(
    VC_investment_pct = VC_investment * 100,
    quality_index_100 = avg_quality_index_4 * 100
  ) %>%
  
  # log transformations
  mutate(
    ln_gdp_pc = log(gdp_pc_const2015usd + 1),
    ln_patents = log(patents_per_1000_researchers + 1),
    ln_bank = log(bank_credit_gdp + 1),
    ln_market = log(market_cap_gdp + 1),
    ln_vc = log(VC_investment_pct + 1),
    ln_trade = log(trade_percent_gdp + 1),
    ln_rd = log(rd_expenditure_percent_gdp + 1),
    ln_tertiary = log(tertiary_enrollment_percent + 1)
  ) %>%
  
  # interaction terms
  mutate(
    ln_bank_x_ipr = ln_bank * ipp_index_IP_transformed,
    ln_market_x_ipr = ln_market * ipp_index_IP_transformed,
    ln_vc_x_ipr = ln_vc * ipp_index_IP_transformed
  )

# convert to panel data
master_panel <- pdata.frame(master_clean, index = c("iso3c", "year"))

# filter nas
master_levels <- master_panel %>%
  filter(
    !is.na(quality_index_100),
    !is.na(patents_per_1000_researchers),
    !is.na(ipp_index_IP_transformed),
    !is.na(gdp_pc_const2015usd)
  )

# split samples
master_bank_market <- master_levels %>% 
  filter(!is.na(bank_credit_gdp) | !is.na(market_cap_gdp))

master_vc <- master_levels %>% 
  filter(!is.na(VC_investment_pct))

#patent quality regressions

# Bank-based FD
qual_bank <- plm(
  quality_index_100 ~ ln_bank + ipp_index_IP_transformed + ln_bank_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# Market-based FD  
qual_market <- plm(
  quality_index_100 ~ ln_market + ipp_index_IP_transformed + ln_market_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# VC-based FD
qual_vc <- plm(
  quality_index_100 ~ ln_vc + ipp_index_IP_transformed + ln_vc_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_vc, 
  model = "within", 
  effect = "twoways"
)

#patent quantity regressions

# Bank FD
count_bank <- plm(
  ln_patents ~ ln_bank + ipp_index_IP_transformed + ln_bank_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# Market FD
count_market <- plm(
  ln_patents ~ ln_market + ipp_index_IP_transformed + ln_market_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# VC FD
count_vc <- plm(
  ln_patents ~ ln_vc + ipp_index_IP_transformed + ln_vc_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_vc, 
  model = "within", 
  effect = "twoways"
)

#clustered se

qual_bank_se <- sqrt(diag(vcovHC(qual_bank, type = "HC1", cluster = "group")))
qual_market_se <- sqrt(diag(vcovHC(qual_market, type = "HC1", cluster = "group")))
qual_vc_se <- sqrt(diag(vcovHC(qual_vc, type = "HC1", cluster = "group")))

count_bank_se <- sqrt(diag(vcovHC(count_bank, type = "HC1", cluster = "group")))
count_market_se <- sqrt(diag(vcovHC(count_market, type = "HC1", cluster = "group")))
count_vc_se <- sqrt(diag(vcovHC(count_vc, type = "HC1", cluster = "group")))

#table one

stargazer(
  qual_bank, qual_market, qual_vc,
  type = "text",
  font.size = "tiny",
  column.sep.width = "0pt",
  single.row = FALSE,
  no.space = TRUE,
  float = FALSE,
  title = "Financial Development, IP Protection and Patent Quality (Log Specification)",
  dep.var.labels = "",
  dep.var.caption = "Dependant Variable: Patent Quality",
  column.labels = c("Bank-based", "Market-based", "VC-based"),
  covariate.labels = c(
    "ln(Bank Credit/GDP)",
    "ln(Market Capitalization/GDP)", 
    "ln(VC Investment/GDP)",
    "IP Protection Index", 
    "ln(Bank FD) × IP Protection", 
    "ln(Market FD) × IP Protection",
    "ln(VC FD) × IP Protection",
    "ln(GDP per Capita)", 
    "ln(Trade/GDP)", 
    "ln(R&D Expenditure/GDP)", 
    "ln(Tertiary Enrollment)"
  ),
  se = list(qual_bank_se, qual_market_se, qual_vc_se),
  omit.stat = c("ser", "f"),
  add.lines = list(
    c("Observations", 
      nobs(qual_bank), 
      nobs(qual_market), 
      nobs(qual_vc)),
    c("R-squared", 
      round(summary(qual_bank)$r.squared["rsq"], 3),
      round(summary(qual_market)$r.squared["rsq"], 3),
      round(summary(qual_vc)$r.squared["rsq"], 3)),
    c("Adj. R-squared", 
      round(summary(qual_bank)$r.squared["adjrsq"], 3),
      round(summary(qual_market)$r.squared["adjrsq"], 3),
      round(summary(qual_vc)$r.squared["adjrsq"], 3)),
    c("F Statistic", 
      paste0(round(summary(qual_bank)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(qual_market)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(qual_vc)$fstatistic$statistic, 2), "***"))
  ),
  notes = paste(
    "All specifications include country and year fixed effects.",
    "Standard errors clustered by country in parentheses.",
    "*p<0.1; **p<0.05; ***p<0.01"
  ),
  align = TRUE
)
#table 2
stargazer(
  count_bank, count_market, count_vc,
  type = "text",  
  font.size = "tiny",
  column.sep.width = "0pt",
  single.row = FALSE,
  no.space = TRUE,
  float = FALSE,
  title = "Financial Development, IP Protection and Patent Quantity (Log Specification)",
  dep.var.labels = "",
  dep.var.caption = "Dependant Variable: Patents per 1,000 Researchers",
  column.labels = c("Bank-based", "Market-based", "VC-based"),
  covariate.labels = c(
    "ln(Bank Credit/GDP)",
    "ln(Market Capitalization/GDP)", 
    "ln(VC Investment/GDP)",
    "IP Protection Index", 
    "ln(Bank FD) × IP Protection", 
    "ln(Market FD) × IP Protection",
    "ln(VC FD) × IP Protection",
    "ln(GDP per Capita)", 
    "ln(Trade/GDP)", 
    "ln(R&D Expenditure/GDP)", 
    "ln(Tertiary Enrollment)"
  ),
  se = list(count_bank_se, count_market_se, count_vc_se),
  omit.stat = c("ser", "f"),
  add.lines = list(
    c("Observations", 
      nobs(count_bank), 
      nobs(count_market), 
      nobs(count_vc)),
    c("R-squared", 
      round(summary(count_bank)$r.squared["rsq"], 3),
      round(summary(count_market)$r.squared["rsq"], 3),
      round(summary(count_vc)$r.squared["rsq"], 3)),
    c("Adj. R-squared", 
      round(summary(count_bank)$r.squared["adjrsq"], 3),
      round(summary(count_market)$r.squared["adjrsq"], 3),
      round(summary(count_vc)$r.squared["adjrsq"], 3)),
    c("F Statistic", 
      paste0(round(summary(count_bank)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(count_market)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(count_vc)$fstatistic$statistic, 2), "***"))
  ),
  notes = paste(
    "All specifications include country and year fixed effects.",
    "Standard errors clustered by country in parentheses.",
    "*p<0.1; **p<0.05; ***p<0.01"
  ),
  align = TRUE
)
#save the html tables to my computer
# 
# stargazer(
#   qual_bank, qual_market, qual_vc,
#   type = "html",
#   title = "Table 1: Financial Development, IP Protection and Patent Quality",
#   dep.var.labels = "Patent Quality Index (0-100 scale)",
#   column.labels = c("Bank-based", "Market-based", "VC-based"),
#   covariate.labels = c(
#     "ln(Bank Credit/GDP)",
#     "ln(Market Capitalization/GDP)", 
#     "ln(VC Investment/GDP)",
#     "IP Protection Index", 
#     "ln(Bank FD) × IP Protection", 
#     "ln(Market FD) × IP Protection",
#     "ln(VC FD) × IP Protection",
#     "ln(GDP per Capita)", 
#     "ln(Trade/GDP)", 
#     "ln(R&D Expenditure/GDP)", 
#     "ln(Tertiary Enrollment)"
#   ),
#   se = list(qual_bank_se, qual_market_se, qual_vc_se),
#   omit.stat = c("ser", "f"),
#   out = "table1_quality_log.html"
# )
# 
# stargazer(
#   count_bank, count_market, count_vc,
#   type = "html",
#   title = "Table 2: Financial Development, IP Protection and Patent Quantity",
#   dep.var.labels = "ln(Patents per 1,000 Researchers)",
#   column.labels = c("Bank-based", "Market-based", "VC-based"),
#   covariate.labels = c(
#     "ln(Bank Credit/GDP)",
#     "ln(Market Capitalization/GDP)", 
#     "ln(VC Investment/GDP)",
#     "IP Protection Index", 
#     "ln(Bank FD) × IP Protection", 
#     "ln(Market FD) × IP Protection",
#     "ln(VC FD) × IP Protection",
#     "ln(GDP per Capita)", 
#     "ln(Trade/GDP)", 
#     "ln(R&D Expenditure/GDP)", 
#     "ln(Tertiary Enrollment)"
#   ),
#   se = list(count_bank_se, count_market_se, count_vc_se),
#   omit.stat = c("ser", "f"),
#   out = "table2_quantity_log.html"
# )
# 
# #sample size summary
# 
# cat("\n\n SAMPLE SIZES \n")
# cat("Bank/Market Models:\n")
# cat("  Quality:", nobs(qual_bank), "observations\n")
# cat("  Quantity:", nobs(count_bank), "observations\n")
# cat("VC Models:\n")
# cat("  Quality:", nobs(qual_vc), "observations\n")
# cat("  Quantity:", nobs(count_vc), "observations\n")
# cat("Countries (Bank/Market):", length(unique(master_bank_market$iso3c)), "\n")
# cat("Countries (VC):", length(unique(master_vc$iso3c)), "\n")

```
#### z-score standardization
```{r eval= FALSE, echo= FALSE}
# z score standardization
# Same models but with standardized variables for effect size comparison, controls are just logged

# Create standardized variables
master_clean <- master_clean %>%
  # standardize variables (z-scores)
  mutate(
    z_quality = as.numeric(scale(quality_index_100)),
    z_patents = as.numeric(scale(ln_patents)),
    z_bank = as.numeric(scale(ln_bank)),
    z_market = as.numeric(scale(ln_market)),
    z_vc = as.numeric(scale(ln_vc)),
    z_ipp = as.numeric(scale(ipp_index_IP_transformed))
  ) %>%
  # Create standardized interactions
  mutate(
    z_bank_x_ipr = z_bank * z_ipp,
    z_market_x_ipr = z_market * z_ipp,
    z_vc_x_ipr = z_vc * z_ipp
  )

# Convert to panel 
master_panel <- pdata.frame(master_clean, index = c("iso3c", "year"))

# filter nas
master_levels <- master_panel %>%
  filter(
    !is.na(quality_index_100),
    !is.na(patents_per_1000_researchers),
    !is.na(ipp_index_IP_transformed),
    !is.na(gdp_pc_const2015usd)
  )

# split samples, just clearly label this, and make it VERY clear in the write-up
master_bank_market <- master_levels %>% 
  filter(!is.na(bank_credit_gdp) | !is.na(market_cap_gdp))

master_vc <- master_levels %>% 
  filter(!is.na(VC_investment_pct))

#quality regressions

# Bank-based FD (standardized)
qual_bank_z <- plm(
  z_quality ~ z_bank + z_ipp + z_bank_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# Market-based FD (standardized)
qual_market_z <- plm(
  z_quality ~ z_market + z_ipp + z_market_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# VC-based FD (standardized)
qual_vc_z <- plm(
  z_quality ~ z_vc + z_ipp + z_vc_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_vc, 
  model = "within", 
  effect = "twoways"
)

# quantity regressions

# Bank FD (standardized)
count_bank_z <- plm(
  z_patents ~ z_bank + z_ipp + z_bank_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# Market FD (standardized)
count_market_z <- plm(
  z_patents ~ z_market + z_ipp + z_market_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_bank_market, 
  model = "within", 
  effect = "twoways"
)

# VC FD (standardized)
count_vc_z <- plm(
  z_patents ~ z_vc + z_ipp + z_vc_x_ipr +
    ln_gdp_pc + ln_trade + ln_rd + ln_tertiary,
  data = master_vc, 
  model = "within", 
  effect = "twoways"
)

#clustered se

qual_bank_z_se <- sqrt(diag(vcovHC(qual_bank_z, type = "HC1", cluster = "group")))
qual_market_z_se <- sqrt(diag(vcovHC(qual_market_z, type = "HC1", cluster = "group")))
qual_vc_z_se <- sqrt(diag(vcovHC(qual_vc_z, type = "HC1", cluster = "group")))

count_bank_z_se <- sqrt(diag(vcovHC(count_bank_z, type = "HC1", cluster = "group")))
count_market_z_se <- sqrt(diag(vcovHC(count_market_z, type = "HC1", cluster = "group")))
count_vc_z_se <- sqrt(diag(vcovHC(count_vc_z, type = "HC1", cluster = "group")))

#patent quality

stargazer(
  qual_bank_z, qual_market_z, qual_vc_z,
  type = "text",
  font.size = "tiny",
  column.sep.width = "0pt",
  single.row = FALSE,
  no.space = TRUE,
  float = FALSE,
  title = "Standardized Coefficients: Financial Development, IP Protection and Patent Quality",
  dep.var.labels = "Patent Quality (z-score)",
  dep.var.caption = "Dependant Variable: Standardized Patent Quality",
  column.labels = c("Bank-based", "Market-based", "VC-based"),
  covariate.labels = c(
    "Bank Credit/GDP (z)",
    "Market Capitalization/GDP (z)", 
    "VC Investment/GDP (z)",
    "IP Protection Index (z)", 
    "Bank FD × IP Protection (z)", 
    "Market FD × IP Protection (z)",
    "VC FD × IP Protection (z)",
    "ln(GDP per Capita)", 
    "ln(Trade/GDP)", 
    "ln(R&D Expenditure/GDP)", 
    "ln(Tertiary Enrollment)"
  ),
  se = list(qual_bank_z_se, qual_market_z_se, qual_vc_z_se),
  omit.stat = c("ser", "f"),
  add.lines = list(
    c("Observations", 
      nobs(qual_bank_z), 
      nobs(qual_market_z), 
      nobs(qual_vc_z)),
    c("R-squared", 
      round(summary(qual_bank_z)$r.squared["rsq"], 3),
      round(summary(qual_market_z)$r.squared["rsq"], 3),
      round(summary(qual_vc_z)$r.squared["rsq"], 3)),
    c("Adj. R-squared", 
      round(summary(qual_bank_z)$r.squared["adjrsq"], 3),
      round(summary(qual_market_z)$r.squared["adjrsq"], 3),
      round(summary(qual_vc_z)$r.squared["adjrsq"], 3)),
    c("F Statistic", 
      paste0(round(summary(qual_bank_z)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(qual_market_z)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(qual_vc_z)$fstatistic$statistic, 2), "***")),
    c("Sample Note", 
      "Bank/Market: N=610", 
      "Bank/Market: N=528", 
      "VC Only: N=329")
  ),
  notes = paste(
    "All specifications include country and year fixed effects.",
    "Financial development and IP protection variables standardized to z-scores (mean=0, SD=1).",
    "Control variables remain in natural logarithms.",
    "Standard errors clustered by country in parentheses.",
    "*p<0.1; **p<0.05; ***p<0.01"
  ),
  align = TRUE
)

#patent quantity table (z-score standardized)

stargazer(
  count_bank_z, count_market_z, count_vc_z,
  type = "text",
  font.size = "tiny",
  column.sep.width = "0pt",
  single.row = FALSE,
  no.space = TRUE,
  float = FALSE,
  title = "Standardized Coefficients: Financial Development, IP Protection and Patent Quantity",
  dep.var.labels = "ln(Patents) (z-score)",
  dep.var.caption = "Dependant Variable: Standardized ln(Patents per 1,000 Researchers)",
  column.labels = c("Bank-based", "Market-based", "VC-based"),
  covariate.labels = c(
    "Bank Credit/GDP (z)",
    "Market Capitalization/GDP (z)", 
    "VC Investment/GDP (z)",
    "IP Protection Index (z)", 
    "Bank FD × IP Protection (z)", 
    "Market FD × IP Protection (z)",
    "VC FD × IP Protection (z)",
    "ln(GDP per Capita)", 
    "ln(Trade/GDP)", 
    "ln(R&D Expenditure/GDP)", 
    "ln(Tertiary Enrollment)"
  ),
  se = list(count_bank_z_se, count_market_z_se, count_vc_z_se),
  omit.stat = c("ser", "f"),
  add.lines = list(
    c("Observations", 
      nobs(count_bank_z), 
      nobs(count_market_z), 
      nobs(count_vc_z)),
    c("R-squared", 
      round(summary(count_bank_z)$r.squared["rsq"], 3),
      round(summary(count_market_z)$r.squared["rsq"], 3),
      round(summary(count_vc_z)$r.squared["rsq"], 3)),
    c("Adj. R-squared", 
      round(summary(count_bank_z)$r.squared["adjrsq"], 3),
      round(summary(count_market_z)$r.squared["adjrsq"], 3),
      round(summary(count_vc_z)$r.squared["adjrsq"], 3)),
    c("F Statistic", 
      paste0(round(summary(count_bank_z)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(count_market_z)$fstatistic$statistic, 2), "***"),
      paste0(round(summary(count_vc_z)$fstatistic$statistic, 2), "***")),
    c("Sample Note", 
      "Bank/Market: N=610", 
      "Bank/Market: N=528", 
      "VC Only: N=329")
  ),
  notes = paste(
    "All specifications include country and year fixed effects.",
    "Financial development, IP protection, and dependent variables standardized to z-scores (mean=0, SD=1).",
    "Control variables remain in natural logarithms.",
    "Standard errors clustered by country in parentheses.",
    "*p<0.1; **p<0.05; ***p<0.01"
  ),
  align = TRUE
)

```

```{r eval=FALSE, echo= FALSE}

library(car)
vif_count_vc_z <- vif(count_vc_z)
vif_count_vc_z

vif_count_market_z <- vif(count_market_z)
vif_count_market_z

vif_count_bank_z <- vif(count_bank_z)
vif_count_bank_z

vif_qual_vc_z <- vif(qual_vc_z)
vif_qual_vc_z

vif_qual_market_z <- vif(qual_market_z)
vif_qual_market_z

vif_qual_bank_z <- vif(qual_bank_z)
vif_qual_bank_z
```

```{r echo=FALSE, eval= FALSE}
# Select key variables for correlation
cor_vars <- master_clean %>%
  select(
    quality_index_100,
    ln_patents,
    ln_bank,
    ln_market, 
    ln_vc,
    ipp_index_IP_transformed,
    ln_gdp_pc,
    ln_trade,
    ln_rd,
    ln_tertiary
  ) %>%
  na.omit()

# Create correlation matrix

if (!dir.exists("figures")) {
  dir.create("figures")
}

cor_matrix <- cor(cor_vars)


library(corrplot)
corr_mtx <- png("figures/correlation_matrix.png", width = 10, height = 8, units = "in", res = 300)
corrplot(cor_matrix, 
         method = "color",
         type = "upper",
         tl.col = "black",
         tl.srt = 45,
         addCoef.col = "black",
         number.cex = 0.7,
         title = "Correlation Matrix of Key Variables",
         mar = c(0,0,2,0))
dev.off()

corr_mtx

```

### Variable Glossary
whatever transformations that end up in the final results will be explained further here:

- `iso3c` - Every country's unique iso3 code, used to standardize and merge all data
- `year` - Observation year
- `country_name` - Country name
- `avg_patent_scope_norm` - Number of countries where patent is filed
- `avg_family_size_norm` - Size of patent family
- `avg_grant_lag_norm` - Days between application and grant
- `avg_bwd_cits_norm` - Number of backward citations
- `avg_npl_cits_norm` - Non-patent literature citations
- `avg_claims_norm` - Number of claims
- `avg_fwd_cits5_norm` - Forward citations within 5 years
- `avg_fwd_cits7_norm` - Forward citations within 7 years
- `avg_generality` - Technological breadth index (0-1)
- `avg_originality` - Citation diversity index (0-1)
- `avg_radicalness` - Novelty index (0-1)
- `avg_quality_index_4` - Composite index (4 indicators)
- `avg_quality_index_6` - Composite index (6 indicators)
- `pct_breakthrough` - Binary indicator (1 = top 1% cited)
- `avg_renewal` - Years patent was renewed
- `VC_investment` - Venture Capital investment as % of GDP
- `ipp_index_IP_transformed` - Park Index of IP protection, 5-year fill interpolation
- `rd_expenditure_percent_gdp` - R&D expenditure as a % of GDP, control
- `trade_percent_gdp` - Trade as a % of GDP, control
- `gdp_pc_const2015usd` - GDP per capita, constant 2015 USD, control
- `tertiary_enrollment_percent` - Tertiary enrollment, control
- `researchers_per_million_x` - Researchers per million, used to scale patent counts
- `population_total` - Alternative scaling variable
- `bank_credit_gdp` - Ratio of bank credit to GDP, represents size of banking sector
- `market_cap_gdp` - Market Cap of domestically listed companies, represents depth of stock market
- `patent_applications_residents` - 
- `researchers_per_million_y` - 
